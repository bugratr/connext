---
sidebar_position: 1
id: quickstart
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Hızlı Başlangıç

Bunlar, Solidity'nin düşük seviyeli "çağrı" yöntemini taklit eden zincirler arası bir ilkel olan "xcall"ın nasıl kullanılacağını gösteren en basit çalışma sözleşmeleridir.

---

## Kurulum

[Node.js](https://nodejs.dev/en/learn/how-to-install-nodejs/) yükleyin ve **Node.js v16** kullanın. Sürüm değiştirmeyi kolaylaştıracak bir düğüm sürüm yöneticisi olan `nvm`yi kurmak için talimatları izleyin.

Connext sözleşme paketinin en son beta sürümünü projenize yükleyin.

```bash npm2yarn
npm install @connext/nxtp-contracts@beta
```

---

## Örnek 1: Merhaba Zincir

Bu örnekte, iki sözleşme vardır. Hedef etki alanındaki "Hedef" sözleşmesinde, güncellemek istediğimiz bir karşılama mesajı bulunur. Kök etki alanındaki "Kaynak" sözleşmesi, kodlanmış çağrı verileri göndererek "Hedef" üzerinde güncellemeyi yürütmek için "xcall"ı kullanır.

### Hedef Kontrat

```solidity
pragma solidity ^0.8.14;

contract Target {
  string public greeting;

  function updateGreeting(string newGreeting) external {
    greeting = newGreeting;
  }
}
```

Amaç, kaynak etki alanından 'updateGreeting'i çağırmaktır.

### Kaynak Kontrat

Kaynak sözleşmesi, zincirler arası işlemi "xcall" ile başlatır.

```solidity
pragma solidity ^0.8.14;

import {IConnextHandler} from "@connext/nxtp-contracts/contracts/core/connext/interfaces/IConnextHandler.sol";
import {CallParams, XCallArgs} from "@connext/nxtp-contracts/contracts/core/connext/libraries/LibConnextStorage.sol";

contract Source {
  // ConnextHandler contract on origin domain
  IConnextHandler public connext = IConnextHandler(0xB4C1340434920d70aD774309C75f9a4B679d801e); 

  // Function that the user will call
  function updateGreeting (address target, string memory newGreeting) external {
    // We're sending calldata, so encode the target function with its arguments
    bytes4 selector = bytes4(keccak256("updateGreeting(string)"));
    bytes memory callData = abi.encodeWithSelector(selector, newGreeting);

    CallParams memory callParams = CallParams({
      to: target, // address of the target contract
      callData: callData, // encoded calldata to execute on destination
      originDomain: 1735353714, // from Goerli
      destinationDomain: 1735356532, // to Optimism-Goerli
      agent: msg.sender, // address allowed to execute transaction on destination side in addition to relayers
      recovery: msg.sender, // fallback address to send funds to if execution fails on destination side
      forceSlow: false, // option to force slow path instead of paying 0.05% fee on fast liquidity transfers
      receiveLocal: false, // option to receive the local bridge-flavored asset instead of the adopted asset
      callback: address(0), // zero address because we're not using a callback
      callbackFee: 0, // fee paid to relayers for the callback; no fees on testnet
      relayerFee: 0, // fee paid to relayers for the forward call; no fees on testnet
      destinationMinOut: 0 // not sending funds so minimum can be 0
    });

    XCallArgs memory xcallArgs = XCallArgs({
      params: callParams,
      transactingAsset: address(0), // 0 address is the native gas token
      transactingAmount: 0, // not sending funds with this calldata-only xcall
      originMinOut: 0 // not sending funds so minimum can be 0
    });

    connext.xcall(xcallArgs);
  }
}
```

---

## Örnek 2: Zincirler Arası Transfer

Bu "XTransfer" sözleşmesi, zincirler arası bir belirteç aktarımı uygular. Hedef tarafta hedef sözleşme yoktur, bu nedenle yalnızca bir sözleşmeye ihtiyaç vardır.

### XTransfer Sözleşmesi

```solidity
pragma solidity ^0.8.14;

import {IConnextHandler} from "@connext/nxtp-contracts/contracts/core/connext/interfaces/IConnextHandler.sol";
import {CallParams, XCallArgs} from "@connext/nxtp-contracts/contracts/core/connext/libraries/LibConnextStorage.sol";
import {ERC20} from "@solmate/tokens/ERC20.sol";

contract XTransfer { 
  // ConnextHandler contract on origin domain
  IConnextHandler public connext = IConnextHandler(0xB4C1340434920d70aD774309C75f9a4B679d801e); 

  // TEST ERC20 token on origin domain
  ERC20 public token = ERC20(0x7ea6eA49B0b0Ae9c5db7907d139D9Cd3439862a1); 

  // Function that the user will call
  function transfer(address recipient, uint256 amount) external {
    require(
      token.allowance(msg.sender, address(this)) >= amount,
      "User must approve amount to this contract"
    );
    
    // User's funds are transferred to this contract
    token.transferFrom(msg.sender, address(this), amount);

    // This contract approves spend to the Connext contract
    token.approve(address(connext), amount);

    CallParams memory callParams = CallParams({
      to: recipient, // wallet receiving the funds on the destination
      callData: "", // empty here because we're only sending funds
      originDomain: 1735353714, // from Goerli
      destinationDomain: 1735356532, // to Optimism-Goerli
      agent: msg.sender, // address allowed to execute transaction on destination side in addition to relayers
      recovery: msg.sender, // fallback address to send funds to if execution fails on destination side
      forceSlow: false, // option to force slow path instead of paying 0.05% fee on fast path transfers
      receiveLocal: false, // option to receive the local bridge-flavored asset instead of the adopted asset
      callback: address(0), // zero address because we're not using a callback
      callbackFee: 0, // fee paid to relayers; relayers don't take any fees on testnet
      relayerFee: 0, // fee paid to relayers; relayers don't take any fees on testnet
      destinationMinOut: (amount / 100) * 99 // minimum amount acceptable due to slippage from the AMM (1% here)
    });

    XCallArgs memory xcallArgs = XCallArgs({
      params: callParams,
      transactingAsset: address(token), // the token being transferred to the target contract
      transactingAmount: amount, // amount of ERC20 to transfer
      originMinOut: (amount / 100) * 99 // minimum amount acceptable due to slippage from the AMM (1% here)
    });

    connext.xcall(xcallArgs);
  }
}
```

Fonlar Connext'in sözleşmeleri aracılığıyla yönlendirileceğinden, kullanıcının önce TEST ERC20'nin 'XTransfer' için bir harcama ödeneğini onaylaması gerekir. 'require' maddesi bu ödeneği kontrol eder.

Bunu yapmak için TEST ERC20'nin "onay" işlevine [Etherscan and write](https://goerli.etherscan.io/address/0x7ea6eA49B0b0Ae9c5db7907d139D9Cd3439862a1#writeContract) kullanabilirsiniz:

<img src="/img/developers/TestERC20_Etherscan_Approve.png" alt="TestERC20 Etherscan Approve" width="400"/>

Tam jeton akışı "Kullanıcının cüzdanı" -> "XTransfer" -> "ConnextHandler" -> "alıcı"dan hareket eder.

---

## Sonraki adımlar

- Gönderdikten sonra bir "xcall"ın [durumunu izlemeyi](../guides/xcall-status.md) deneyin.
- [authentication](../guides/authentication.md) adresindeki kılavuzu inceleyin.
- Origin etki alanındaki yürütme sonuçlarını işlemek için [geri aramaların nasıl kullanılacağına](../guides/xcall-callback.md) bakın.
- Aşağıdaki xApp Başlangıç Setini çatallayın ve kendi xApp'inizi oluşturun.

[xApp Başlangıç Seti](https://github.com/connext/xapp-starter/)
